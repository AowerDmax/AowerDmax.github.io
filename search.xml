<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[英语网课注册]]></title>
    <url>%2F2019%2F09%2F10%2F%E8%8B%B1%E8%AF%AD%E7%BD%91%E8%AF%BE%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[英语网课注册英语课程的成绩组成 成绩 占比 考试内容 时间 水平成绩 30% 水平考试 1小时 扩展成绩 50% 扩展考试 1小时三十分钟 平时成绩 20% 考勤+日常作业 上课期间 水平考试占总评30%大二期末水平测试题型与命题范围 Writing (15%) Part II. Part I. Listening Comprehension (40%)新闻：8个题目，8%长对话：2篇，7个题目，7%文章：3篇，共10个题目，10%听写：1篇 10空，10个词及短语，15%出题范围：出自《新标准大学英语视听说教程III》、《新视野大学英语听说教程III》 Part III. Reading Comprehension (40%)1篇文章选词填空（15个词选10个），20%出题范围：取材自《新标准大学英语综合教程III》课文（A班为教程IIII）1篇长篇阅读文章（10个句子与段落匹配），20%出题范围：《新标准大学英语长篇阅读III》 Part IV. Translation (20%)段落翻译出题范围：《新标准大学英语综合教程III》课文1-8单元；课后汉译英翻译练习1-8单元；A班为教程IIII） 扩展成绩这个和自己选择的英语课类型有关系 网课注册下面是本文的重点英语网课的注册 这学期网课的学习是要求自学的，包含u校园以及我们的长篇阅读教材， 此部分不加分， 但是完不成会扣分。 首先我们打开u校园网址 u校园 登陆之后 点击加入班级吗， 输入老师给的班级号， 然后加入就好了 在这里， 我们需要激活的是视听说3和听说3，这两本教材。 大家记得按时完成作业]]></content>
      <tags>
        <tag>英语</tag>
        <tag>学习委员</tag>
        <tag>网课注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于gitbook搭建到github上的个人笔记搭建指北]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%9F%BA%E4%BA%8Egitbook%E6%90%AD%E5%BB%BA%E5%88%B0github%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[word版本管理工具]]></title>
    <url>%2F2019%2F07%2F21%2Fword%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[最近在用word写论文， 虽然我认为word并不是一个写论文的好工具。 但毕竟写论文是一个团队协作共同完成的工作，也要配合团队其他成员所使用的工具 所以最终我们选择了word 但是在攥写论文的过程中，我发现了一系列的问题 因为论文需要不断的更改，加上命名不规范， 最终会导致一系列的问题， 如下图所示， 随着时间和文件数目的增多， 我们最终会忘记每个文件都更改了什么， 无法快速找到自己想要的版本 无法快速的对任意两个版本之间的不同进行比较 在多人协作的时候，往往因为论文的整合而出现一些问题 团队使用q q作为通讯联络工具， 在进行多人讨论时，随着聊天记录的边长， 往往会遗漏一些要点 所以针对以上问题， 我寻找了一款名叫Simul的网页版的word版本控制工具 开始时想要使用Git工具， Github是流行的文本版本控制工具，在工业界和程序员中取得了巨大成功，但Github也具有其自身的局限，只支持纯文本，不支持像Word一样的富文本。这让Github在需要富文本编辑的场景中严重水土不服。Simul，就是解决这一痛点，把Github的版本控制功能整合到Word的富文本文档中。 Simul是一个文档协作工具，把Github的优秀版本控制特性带到Word中来。该工具为长期与他人协作编辑文档的人群量身打造，比如学者、律师、记者、作家。以学术工作者为例，无论你是学生还是导师，在书写手稿的时候，是不是有无数个v1,v1_1,v2_1,…，是不是需要无数次的从不同版本中进行人工的比较、编辑和整合。这样的痛苦可能存在于每个需要协作编辑的文字工作者中，Simul为你解决以上痛点。 那么话不多说我们就开始今天的教程吧h h 访问 simul 官网 点击 Get started for free 下方的 register 根据要求进行注册， 这里推荐使用Google账号进行注册， 如果实在没有也没有关系， 第一个是组织名称，第二个是你的名字， 这些都不重要， 最重要的是你的邮箱和密码， 国内可能速度会慢一些， 但还是可以使用的， 然后再最下面的I configure 那里打上对号 登陆后的界面如下， 点击add a new document 点击之后会弹出一个窗口 第一个upload指的是你从本地上传word文档 第二个是创建一个空白的文档 第三个是从你的云盘文件中导入， 支持SharePoint， OneDrive， Dropbox， Google drive， box 可以说是非常良心了 ， 我平常对一些重要文件进行Dropbox备份， 可以说是非常贴近我的用户习惯了h h， 因为我这里使用的是免费版的， 最多只能上传十篇word（只要你邮箱多， 那你就是无数个）滑稽 点击中间的browse， 找到本地你想要上传的word文档， 然后点击右下角的打开 至于最下面的， 是询问你是否要创建一个文件夹， 我觉得十篇word没必要， 所以直接点击upload 然后点击close， 你就可以看到你的文档已经上传了， 左键单击你上传的项目， 会得到如下的界面 部分说明我已经在图上进行了说明 先点击右上角的三个点， 出现菜单栏 我们经常用到的按钮是 Download a copy 还有 import a new version publish this version 指的是将当前文档设置为主分支， 可以更好的进行版本控制 name this version 对当前版本进行重命名 push to copy 协同工作的时候很有用 Download a copy 将当前版本下载下来 import a new version上传一个新的版本 下面我对我上传的test文档进行一定的修改， 注意是在本地更改， 网页上不可以更改 ，网页上只能预览， 除非你有office365. 将第二个是创建一个空白的文档第二个是创建一个空白的文档这句话更改为快速的棕色狐狸跳过懒狗 在最下面增加word这句话， 然后import a new version 至于upload in separate brank这个是指创建一个新的分支， 当你有多种想法的时候， 可以使用这个来朝着不同方向进行， 这里我们直接点击IMPORT 通过给自己创建任务 防止自己遗忘重要事情，尤其是当q q聊天记录过多时 可以给自己设定期限， 给自己完成任务的紧迫感 可以提醒搭档， 更好的分工配合 同时simul还支持多人协作的模式 在email 那里填写你同伴的email地址 下面是给你的同伴说明权限， 是贡献者， 还是主人， 还是只能观看 最后点击invite就完成了 这些只是simul的基本操作 如果你想要继续深入的学习， 这里推荐simul的介绍和说明文档]]></content>
      <tags>
        <tag>版本管理</tag>
        <tag>word</tag>
        <tag>多人协作</tag>
        <tag>版本回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F07%2F21%2FGit%2F</url>
    <content type="text"><![CDATA[Git是一个版本管理的工具， 他可以在 Git与svn对比svnsvn是集中式版本控制系统， 版本库是集中放在中央服务器， 而干活的时候， 用的都是自己的电脑， 所以首先要从中央服务器那里得到最新的版本， 然后干活， 干完后， 需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作， 如果在局域网还可以， 带宽够大， 速度够快， 如果在互联网下， 如果网速慢的话， 就郁闷了。 集中管理方式在一定程度看到其他开发人员在什么， 而管理员也可以很轻松掌握每个人的开发权限 但是相较于其优点而言， 集中式版本控制工具缺点很明显 服务器单点故障 容错性差 GitGit是分布式版本控制系统， 那么它就没有中央服务器的， 每个人的电脑上就是一个完整的版本库， 这样， 工作的时候就不需要联网了， 因为版本都是在自己的电脑上， 既然每个人的电脑上都有一个完整的版本库， 那多个人如何协作呢？比如说自己在电脑上改了文件A， 其他人也在电脑上改了文件A， 这时， 你们两之间只需把各自的修改推送给对方， 就可以互相看到对方的修改了 git工作流程 从远程仓库中克隆Git资源作为本地仓库 从本地仓库中cheekout代码然后进行代码修改 在提交前先将代码提交到暂存区 提交修改， 提交到本地仓库， 本地仓库中保存修改的各个历史版本 在修改完成后， 需要和团队成员共享代码时， 可以将代码push到远程仓库 Git的安装默认选项无需更改 推荐安装到默认的安装路径 git bash here 会打开一个命令行窗口， 里面的Linux命令都适用 12git --version#可以看到当前安装的git的版本信息· Git的基本使用小结现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 使用命令git commit -m &lt;message&gt;，完成。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： cat &lt;filename&gt;在命令行窗口中打开你想要的文件 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 小结现在总结一下： git diff比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件后，运行 git diff 后却什么也没有，就是这个原因。 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 小结现在总结一下 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： 每次修改，如果不用git add到暂存区，那就不会加入到commit中。 小结现在总结一下 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 小结又到了小结时间。 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 小结又到了小结时间 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt 小结又到了小结时间 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。]]></content>
      <tags>
        <tag>git</tag>
        <tag>版本管理</tag>
        <tag>实用小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言基本语法与绘图指北]]></title>
    <url>%2F2019%2F07%2F21%2FR%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%98%E5%9B%BE%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[本来想要昨天晚上完成第二篇文章的， 但是发现把学习笔记放在自己的博客上并托管到GitHub上之后， 后期查找的时候并不是特别方便， 所以昨天一直捣弄GitBook， 确实还算不错， 先试用一段时间吧， 如果好用的话， 会后续写一篇入门教程 h h 那么就开始今天的主题，R语言的基本语法与绘图指北 图像可以说是最直观的内容呈现形式了， 所以我们做研究的时候往往需要绘制专业并且美观的图片， 所以今天我首推的工具就是R语言 为什么要学习R语言？ 免费，开源 专业的统计分析软件 作图能力强 对各种平台和数据源的兼容性强 R语言基本语法R语言在使用中可以使用Tab键进行代码的自动补全 在R中可以通过ctrl+enter运行当前行（和jupyter notebook一样的h h） 可以用shift + enter 把代码整体下移一行 变量赋值12345678a &lt;- 10b &lt;- 10#可能很多人都感觉这个好奇怪， 其实把&lt;-看成箭头， 指向变量#是不是就很容易记住了c &lt;- "课程"#在给字符串赋值的时候需要使用双引号d &lt;- c(1, 2, 3, 4)#c指的是combine， 组合 ，将这些元素组合成为一个组 运算1234567891011121314151617a &lt;- 5b &lt;- 2#给a， b赋值a/5#a除以b， 结果为2.5a*5#a乘以b， 结果为10a+b#a加ba-b#a减ba^3#a的三次方a%%b#a对b取余， 结果为1a%/%b#a对b整出， 结果为2 &lt; 小于 &lt;= 小于等于 == 等于 != 不等于 !x 非 x|y 或 x&amp;y 与 控制结构1234567891011121314151617181920212223# [0, 60)不合格， [60, 80)合格[80， 100]优秀grade&lt;-45&#123; if(grade&gt;=80) print("优秀") else if(grade&gt;=60) print("合格") else print("不合格")&#125;#增添大括号的原因是将这些代码看成一行一起运行i &lt;- 10while(i &gt; 0)&#123; print(i) i&lt;-i - 2&#125;for(i in 1:10) print("Hi")#输出十次Hi# for(i in x) 对x中的所有元素全部进行一次操作a &lt;- c(10, 20, 30, 40)for(i in a) print(i * 10) 访问数据集12345678a &lt;- c(10, 20, 30, 40)a[1]#得到a中的第一个元素10a[2]#得到a中的第二个元素20#和c++中的数组或者python中的list差不多， 但是下标是从一开始a[c(1, 4)]# 得到a中的第一个元素10和第四个元素40 扩展包的管理扩展包的作用能实现某方面需求的功能集合 安装包12install.packages("包的名称")#需要使用双引号 加载包12library(包的名称)#不需要使用双引号 查看当前已经安装的包1installed.packages() R语言的数据结构向量vector 向量：用于储存数值型、字符型或逻辑型的一堆数组 数据类型： 数值型数据：1， 2， 3 字符型数据：a， b， c 逻辑型数据：TRUE， FALSE 1234#向量生成a&lt;-c(1, 2, 3, 4, 5)b&lt;-c("red", "blue", "black")c&lt;-c(TRUE, FALSE, FALSE) 访问向量中的元素 访问a中的第一个元素a[1],得到结果1 访问a中的第一个元素和第四个元素a[c(1, 4)]得到结果1， 4 单个向量中的数据类型必须是相同的数据类型 矩阵matrix 矩阵 ：二维的数据集， 且每个元素都是相同的数据类型 矩阵生成 1234567891011121314matrix(vector, nrow, ncol, byrow, dimnames)m1 &lt;- matrix(1:20, nrow = 5, ncol = 4)#按照列排序#1 6 11 16#2 7 12 17#3 8 13 18#4 9 14 19 #5 10 15 20m1 &lt;- matrix(1:20, nrow = 5, ncol = 4， byrow = TRUE)#按照行排序#dimnames给矩阵的行和列命名n1 &lt;- c("a", "b", "c", "d")n2 &lt;- c(1, 2, 3, 4 ,5)m1 &lt;- matrix(1:20, nrow = 5, ncol = 4， byrow = TRUE, dimnames = list(n2, n1)) 访问矩阵中的元素 12345678m1[2, 4]#访问matrix中的第二行第四列的元素m1[2, c(2, 3)]#访问matrix中的第二行， 第二列第三列的元素m1[3,]#访问matrix中第三行的元素m1[,4]#访问matrix中第四列的元素 数组array 数组：数组与矩阵类似，但是维度可以大于2 数组生成 123456789array(vector, dimensions, dimnames)array1 &lt;- array(1:24, c(2, 3, 4))#两行三列四个矩阵array2 &lt;- array(1:48, c(2, 3, 4， 2))#一个四行三列的矩阵matrix， 其中每个矩阵里面的元素又是一个两行三列的矩阵n1 &lt;- c("x1", "x2")n2 &lt;- c("y1", "y2", "y3")n3 &lt;- c("z1", "z2", "z3", "z4")array1 &lt;- array(1:24, c(2, 3, 4), dimnames = list(n1, n2, n3)) 访问数组中的元素 array1[2, 3, 1] 数据框dataframe 数据框：由不同的列（可以是不同的数据类型）组成 数据框组成 123456789data.frame(col1, col2, col3, ...)#年龄age &lt;- c(21, 22, 23, 24)#性别gender &lt;- c("female", "male", "female", "female")#成绩grade &lt;- c(91, 92, 93, 94)df1 &lt;- data.frame(age, gender, grade)df1 访问数据框中的元素 通过下标 通过列名 通过美元符号 123456789101112131415df1[1, ]#访问第一行df2[ , 2]#访问第二列df1[, 1:3]#访问第一列， 第二列， 第三列df1[-1, ]#访问除了第一行意外的其他行df1["age"]df1[c("age", "grade")]df$age#记得按Tab键 列表list 列表：就是一些对象的有序集合， 这些对象可能是向量、矩阵、数组、数据框、其他列表的组合 列表的生成 1list1 &lt;- list(obj1, obj2, obj3, ...) 访问列表中的元素 123456789101112131415list1[[2]]#通过双重括号来访问列表中第二个对象-obj2#查看obj2的数据类型， 然后根据obj2的数据类型， 进行不同的访问list[[2]][2, 2]list$obj2#如果第二个对象有命名，则可以通过美元符号来访问第二个对象v1 &lt;- c(1, 2, 3, 4)m1 &lt;- matrix(1:20, nrow = 4, ncol = 5)age &lt;- c(11, 12, 13)country &lt;- c("China", "Japan", "American")df1 &lt;- data.frame(age, country)list1 &lt;- list(x = v1, y = m1, z = df1)list1&amp;xlist1$ylist1$z 导入与导出数据getwd()得到当前的工作目录 导入数据流程 通过setwd()重置工作目录 将Excel文件另存为csv格式文件， 并存入到新的工作目录中 输入read.csv(“csv文件名称及其后缀”) 导出数据流程 通过setwd()重置工作目录 输入write.csv(要导出的数据集,“csv文件名称及其后缀”) 输入write.csv(要导出的数据集,“csv文件名称及其后缀” ,row.names = FALSE), 不输出索引行 ggplot2绘图介绍ggplot2功能 ggplot2是一个作图包 可以创建诸如散点图、线图、柱状图等图表， 将数据可视化呈现 123#ggplot2是一个扩展包install.packages("ggplot2")library(ggplot2) 要素 ggplot2要素主要包括： 背景，坐标轴， 图形， 标题， 图例， 分面， 文本注释 一个具有诚意的ggplot2的作图应该是这样子的： 1234ggplot(data, aes(x, y))+geom_xx()+annotate()+labs()+facet_grid()+...# annotate 文本注释的一个函数# labs 标题， 可以添加坐标的标题# facet_grid() 是一个封面函数 理念 ggplot2的核心理念是：将绘图与数据相分离 有命令式作图的调整函数， 可以随时更换参数来调整图形， 更具灵活性 12345ggplot(data, aes(x, y))+ #初始化图形并指定数据源和作图变量， aes美学英文的首字母缩 写geom_XX()+ #制定图形的类型 geom是几何学英文的首字母缩写annotate()+ #添加文本注释labs()+ #修改主标题和坐标轴标题... 逻辑 ggplot2是按照图层叠加作图的， 通过+号叠加， 越到后面图层越高 ggplot2作图符合人的认知， 有明确的起点和终点， 由ggplot开始做图可以在后面的任一叠加函数停止作图 作图类型散点图 作用：描绘两组变量的关系情况 代码：ggplot(data, aes(x, y)) + geom_point() 线图 作用：描绘两组变量的关系情况 代码：ggplot(data, aes(x, y)) + geom_line() 柱状图 作用：查看变量的频数分布情况 ggplot(data, aes(x)) + geom_bar() 123456class()#可以查看变量类型numeric 数字类型需要转换成分子， factor()分类变量 直方图 查看变量的分布情况 代码：ggplot(data, aes(x)) + geom_histogram() 密度图 作用：查看变量的频率分布情况 代码： ggplot(data, aes(x)) + geom_density() 箱线图 作用：查看变量的统计值分布情况 代码： ggplot(data, aes(x， y)) + geom_boxplot() 分组作图分组变量的数据类型123456ggplot(mtcars,aes(wt, mpg, color = qsec)) + geom_point()#渐变的颜色来做图#wt作为x轴#mpg作为y轴#qsec作为染色的标志， 连续性的变量， 可以使用连续性的表尺ggplot(mtcars, aes(wt, mpg, color = factor(vs))) + geom_point() color与fill的区别color是对点、线、 或者是图形的边界进行填色 fill是对图形的内部进行填充 参数在aes内和外的区别在aes内的时候， 会查找数据集中是否有这个变量，然后根据这个来渐变颜色， 如果使用factor颜色区分会很明显 想用颜色来分组 1ggplot(mtcars,aes(wt, mpg, color = qsec)) + geom_point() 在aes外部的时候会把所有的点、线染成你想要的颜色 统一图层的颜色 1ggplot(mtcars,aes(wt, mpg) + geom_point(color = "blue"))]]></content>
      <tags>
        <tag>R语言</tag>
        <tag>绘图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ss/ssr搭建指北]]></title>
    <url>%2F2019%2F07%2F21%2Fss-ssr%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"></content>
      <tags>
        <tag>ssr</tag>
        <tag>科学上网</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类图的分析与研究]]></title>
    <url>%2F2019%2F07%2F21%2F%E8%81%9A%E7%B1%BB%E5%9B%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[最近在做一些关于分析评论以及情感分析的研究 其中用到了kmeans、 fcm、 dbscan等一些聚类算法 k-means 聚类 聚类算法有很多种，K-Means 是聚类算法中的最常用的一种，算法最大的特点是简单，好理解，运算速度快，但是只能应用于连续型的数据，并且一定要在聚类前需要手工指定要分成几类。 K-Means 聚类算法的大致意思就是“物以类聚，人以群分”： 首先输入 k 的值，即我们指定希望通过聚类得到 k 个分组；从数据集中随机选取 k 个数据点作为初始大佬（质心）；对集合中每一个小弟，计算与每一个大佬的距离，离哪个大佬距离近，就跟定哪个大佬。这时每一个大佬手下都聚集了一票小弟，这时候召开选举大会，每一群选出新的大佬（即通过算法选出新的质心）。如果新大佬和老大佬之间的距离小于某一个设置的阈值（表示重新计算的质心的位置变化不大，趋于稳定，或者说收敛），可以认为我们进行的聚类已经达到期望的结果，算法终止。 如果新大佬和老大佬距离变化很大，需要迭代3~5步骤。 原文 推荐阅读 为了使结果更加美观， 可视化， 易于理解， 在这里就推荐几种可视化聚类算法的方法 matlab最经典的方法， 网上相关的教程也是最多的， 但也衍生了一个问题， 就算画出来的图是最土的， 没有新鲜感， 在这里我们对这种方法不做介绍， 如果想要了解， 可以通过百度， Google（推荐）搜索得到相关的教程 R语言在这里我首推R语言， R语言具有简单易学易上手的特点， 各种扩展包也很丰富， 在使用过程中带来了极大的遍历， 当然主要是ggplot2包太好用了h h 关于R语言的使用， 可以看我的另一篇博文 或者观看B站up主阿雷边学边教的关于R语言的教程， 讲解非常棒啊h h 其实不需要把R语言学的特别精通， 了解基本的语法以及数据结构后（data.frame数据切片， 一定要好好学， 用处大大的）， 就可以通过Google搜索你想要实现的功能， 然后通过观看官方文档或者Stack Overflow来进行更一步的学习 这里推荐两份很棒的学习文档, 都是中文版的， 阅读很方便 基于R语言的科研信息分析与服务 数据科学中的R语言, 这两份文档都是由一名西南交通大学量子物理专业博编写的 Quick-R 通过设置 ellipse.type = “convex” 得到图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556setwd("C:/Users/hu1329210652/Desktop/R")# 清空环境rm(list=ls())data("USArrests")class(USArrests)site="https://mirrors.tuna.tsinghua.edu.cn/CRAN"package_list = c("factoextra","cluster")for(p in package_list)&#123; if(!suppressWarnings(suppressMessages(require(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))))&#123; install.packages(p, repos=site) suppressWarnings(suppressMessages(library(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))) &#125;&#125;kMeans = read.csv("kMeans.csv")class(kMeans)kMeansrow.names(kMeans) &lt;- c("豆瓣", "韩剧TV", "知乎", "易信", "百度贴吧", "网易大神", "小红书", "QQ", "旺信", "堆糖", "音遇", "微信", "QQ空间", "美篇" )kMeanskMeans = na.omit(kMeans)head(kMeans, n=6) desc_stats = data.frame( Min=apply(kMeans, 2, min),#minimum Med=apply(kMeans, 2, median),#median Mean=apply(kMeans, 2, mean),#mean SD=apply(kMeans, 2, sd),#Standard deviation Max=apply(kMeans, 2, max)#maximum)desc_stats = round(desc_stats, 1)#保留小数点后一位head(desc_stats)desc_statsdf = scale(kMeans)res = get_clust_tendency(df, 5, graph = TRUE)res$hopkins_statkm.res = kmeans(df, 3, nstart = 25)fviz_cluster(km.res, kMeans, xlab = FALSE, #不显示x坐标 ylab = FALSE, #不显示y坐标 main = "Kmeans",#标题 ellipse.type = "convex",#设置椭圆的类型 ellipse.level = 0.95, ellipse.alpha = 0.2, labelsize = 23)#设置字体的大小 通过设置 ellipse.type = “euclid” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556setwd("C:/Users/hu1329210652/Desktop/R")# 清空环境rm(list=ls())data("USArrests")class(USArrests)site="https://mirrors.tuna.tsinghua.edu.cn/CRAN"package_list = c("factoextra","cluster")for(p in package_list)&#123; if(!suppressWarnings(suppressMessages(require(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))))&#123; install.packages(p, repos=site) suppressWarnings(suppressMessages(library(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))) &#125;&#125;kMeans = read.csv("kMeans.csv")class(kMeans)kMeansrow.names(kMeans) &lt;- c("豆瓣", "韩剧TV", "知乎", "易信", "百度贴吧", "网易大神", "小红书", "QQ", "旺信", "堆糖", "音遇", "微信", "QQ空间", "美篇" )kMeanskMeans = na.omit(kMeans)head(kMeans, n=6) desc_stats = data.frame( Min=apply(kMeans, 2, min),#minimum Med=apply(kMeans, 2, median),#median Mean=apply(kMeans, 2, mean),#mean SD=apply(kMeans, 2, sd),#Standard deviation Max=apply(kMeans, 2, max)#maximum)desc_stats = round(desc_stats, 1)#保留小数点后一位head(desc_stats)desc_statsdf = scale(kMeans)res = get_clust_tendency(df, 5, graph = TRUE)res$hopkins_statkm.res = kmeans(df, 3, nstart = 25)fviz_cluster(km.res, kMeans, xlab = FALSE, #不显示x坐标 ylab = FALSE, #不显示y坐标 main = "Kmeans",#标题 ellipse.type = "euclid",#设置椭圆的类型 ellipse.level = 0.95, ellipse.alpha = 0.2, labelsize = 23)#设置字体的大小 通过设置ellipse.type = “norm” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556setwd("C:/Users/hu1329210652/Desktop/R")# 清空环境rm(list=ls())data("USArrests")class(USArrests)site="https://mirrors.tuna.tsinghua.edu.cn/CRAN"package_list = c("factoextra","cluster")for(p in package_list)&#123; if(!suppressWarnings(suppressMessages(require(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))))&#123; install.packages(p, repos=site) suppressWarnings(suppressMessages(library(p, character.only = TRUE, quietly = TRUE, warn.conflicts = FALSE))) &#125;&#125;kMeans = read.csv("kMeans.csv")class(kMeans)kMeansrow.names(kMeans) &lt;- c("豆瓣", "韩剧TV", "知乎", "易信", "百度贴吧", "网易大神", "小红书", "QQ", "旺信", "堆糖", "音遇", "微信", "QQ空间", "美篇" )kMeanskMeans = na.omit(kMeans)head(kMeans, n=6) desc_stats = data.frame( Min=apply(kMeans, 2, min),#minimum Med=apply(kMeans, 2, median),#median Mean=apply(kMeans, 2, mean),#mean SD=apply(kMeans, 2, sd),#Standard deviation Max=apply(kMeans, 2, max)#maximum)desc_stats = round(desc_stats, 1)#保留小数点后一位head(desc_stats)desc_statsdf = scale(kMeans)res = get_clust_tendency(df, 5, graph = TRUE)res$hopkins_statkm.res = kmeans(df, 3, nstart = 25)fviz_cluster(km.res, kMeans, xlab = FALSE, #不显示x坐标 ylab = FALSE, #不显示y坐标 main = "Kmeans",#标题 ellipse.type = "norm",#设置椭圆的类型 ellipse.level = 0.95, ellipse.alpha = 0.2, labelsize = 23)#设置字体的大小 Python当然还有一种绘图的方法就是调用Python里面的matplotlib库]]></content>
      <tags>
        <tag>绘图</tag>
        <tag>数据分析</tag>
        <tag>聚类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析Pandas]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90Pandas%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析numpy]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90numpy%2F</url>
    <content type="text"><![CDATA[Python数据分析之numpyNumpy是Python的一种开源的数值计算扩展。这种工具可用来储存和处理大型矩阵比Python自身的嵌套列表（nested list structure）结构要高效的多。numpy提供了许多高级的数值编程工具。Numpy的一个重要特性是它的数组计算，是做数据分析必不可少的一个包 导入python库使用关键字import， 后面可以自定义库的简称， 但是一般都将Numpy命名为np， pandas命名为pd 使用前一定要先导入Numpy包， 导入的方式有以下几种 import numpy 导入numpy包， 在使用numpy里面的函数时， 必须是numpy. 的形式 import numpy as np 导入numpy包， 并将其重命名为np， 在使用numpy里的函数时， 必须是 np. 的形式 from numpy import * 不用加任何前缀， 速度较慢， 且容易发生冲突， 不建议使用 1import numpy as np 1.Numpy的数组对象及其索引数组上的数学操作假如我们想将列表中的每个元素增加1，但列表不支持这样的操作： 12a = [1, 2, 3, 4, 5][x+1 for x in a] [2, 3, 4, 5, 6]12b = [2, 3, 4, 5, 6]a+b [1, 2, 3, 4, 5, 2, 3, 4, 5, 6]zip是一个打包命令可以让a, b 列表组成一个一个的数对 1[x+y for (x, y) in zip(a, b)] [3, 5, 7, 9, 11]与另一个数组相加，得到对应元素相加的结果： 这样的操作比较麻烦，而且在数据量特别大的时候会非常耗时间如果我们使用numpy， 就会变得特别简单初始化一个numpy数组12a = np.array([1, 2, 3, 4])a array([1, 2, 3, 4])1a+1 array([2, 3, 4, 5])1a * 2 array([2, 4, 6, 8])产生数组从列表产生数组 123list1 = [1, 2, 3, 4]my_list = np.array(list1)my_list array([1, 2, 3, 4])从列表传入数组 12my_list = np.array([0, 1, 2, 3])my_list array([0, 1, 2, 3])生成全0数组 1np.zeros(5) array([0., 0., 0., 0., 0.])生成全1数组 默认生成的数组为浮点型， 若要进行类型的转换可以使用dtype 1np.ones(5,dtype = 'int') array([1, 1, 1, 1, 1])可以使用fill方法将数组设为指定值 123a = np.zeros(6, dtype = 'int')a.fill(5)a array([5, 5, 5, 5, 5, 5])与列表不同， 数组中要求所有元素的type是一样的， 如果传入参数的类型与数组类型不一样， 需按照已有的类型进行转换 12a = a.astype('float')a array([5., 5., 5., 5., 5., 5.])还可以使用一些特定的方法生成特殊数组 生成整数序列 123# 生成整数序列， 左闭右开， 不包含右边a = np.arange(1, 10)a array([1, 2, 3, 4, 5, 6, 7, 8, 9])123# 第三个参数指定相邻元素的差值a = np.arange(1, 10, 2)a array([1, 3, 5, 7, 9])生成等差数列 123# linsapce 生成等差数列， 包含1到10， 平均等分为19份a = np.linspace(1, 10, 19)a array([ 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5, 7. , 7.5, 8. , 8.5, 9. , 9.5, 10. ])生成随机数 123# 生成的随机数分布在0~1之间， 左闭右开# 生成10个随机数np.random.rand(10) array([0.47858337, 0.27552828, 0.23564354, 0.32176268, 0.0649055 , 0.06550039, 0.10144269, 0.09723159, 0.39374272, 0.2053621 ])服从标准正态分布的随机数 1np.random.randn(10) array([-1.71106368, 0.01290357, 0.11539743, 0.0945762 , 0.27211728, -1.72631161, -0.07228001, 1.78744359, -0.04889052, 0.47681058])1np.random.randint(1, 10, 10) array([4, 7, 2, 1, 7, 7, 3, 9, 7, 7])数组属性查看类型 1a array([ 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5, 7. , 7.5, 8. , 8.5, 9. , 9.5, 10. ])1type(a) numpy.ndarray查看数组中的数据类型 1a.dtype dtype(&apos;float64&apos;)查看形状， 会返回一个元组， 每一个元素代表这一堆的元素数目 1a.shape (19,)或者使用： 1np.shape(a) (19,)1np.size(a) 19查看数组里面元素的数目 1a.size 19查看数组的维度 1a.ndim 1索引和切片和列表相似， 数组也支持索引和切片操作 索引第一个元素 12a = np.array([1, 2, 3])a[0] 1修改第一个元素的值 12a[0] = 10a array([10, 2, 3])切片， 支持负索引： 12# 注意左闭右开a[::-1] array([ 3, 2, 10])假设我们记录一部电影的累计票房 12ob = np.array([1000, 2100, 3300, 4600, 6000])ob array([1000, 2100, 3300, 4600, 6000])可以这样计算每天的票房 12front_ob = ob[:-1]front_ob array([1000, 2100, 3300, 4600])12back_ob = ob[1:]back_ob array([2100, 3300, 4600, 6000])12end_ob = back_ob - front_obend_ob array([1100, 1200, 1300, 1400])多维数组及其属性array还可以用来生成多为数组 12a = np.array([[0, 1, 2, 3], [10, 11, 12, 13]])a array([[ 0, 1, 2, 3], [10, 11, 12, 13]])事实上我们传入的是一个以列表为元素的列表， 最终得到一个二维数组 查看形状 1np.shape(a) (2, 4)查看总的元素个数 1a.size 8查看维数 1a.ndim 2各维数组索引对于二维数组， 可以传入两个数字来索引 1a array([[ 0, 1, 2, 3], [10, 11, 12, 13]])可以通过两个中括号的形式或者一个中括号里面有逗号的形式来进行索引 12a[1][2]a[1, 3] 13可以使用单个索引来索引一整行的内容 也可以使用索引来给一整行进行赋值 1a[0] array([0, 1, 2, 3])可以使用索引来索引一整列的内容 1a[:, 1] array([0, 1, 2, 3])多维数组的切片多维数组， 也支持切片操作 12a = np.array([[1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])a array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])想得到第一行的第四和第五两个元素 1a[0, 4:6] array([5, 6])想得到最后两行的最后两列 1a[-2:,-2:] array([[47, 48], [57, 58]])得到第三列 1a[:, 2] array([ 3, 13, 23, 33, 43, 53])每一维都支持切片的规则，包括负索引， 省略 [lower:upper:step] 取出3， 5行的奇数列 1a[3::2, ::2] array([[31, 33, 35, 37], [51, 53, 55, 57]])切片是引用 切片在内存中使用的是引用机制 列表list和数组使用的机制是不一样的 list使用copy 数组使用引用 12345a = np.array([1, 2, 3, 4, 5])b = a[1:3]print(b)b[0] = 10print(a) [2 3] [ 1 10 3 4 5]123456a = [1, 2, 3, 4, 5]b = a[2:3]print(b)b[0] = 10print(b)print(a) [3] [10] [1, 2, 3, 4, 5]引用机制意味着， Python并没有为b分配新的空间来储存它的值， 而是让b指向了a所分配的内存空间， 因此， 改变b 会改变a 的值 这样做的好处在于， 对于很大的数组， 不用大量复制多余的值， 节省了空间 缺点在于， 可能出现改变一个值改变另一个值的情况 一个解决方案是使用copy()方法产生一个复制， 这个复制会申请新的内存 12345a = np.array([1, 2, 3, 4, 5])b = a[2:4].copy()print(b)b[0] = 10print(a) [3 4] [1 2 3 4 5]花式索引切片只能支持连续或者等间隔的切片操作， 要想实现任意位置的操作， 需要使用花式索引 fancy slicing 一维花式索引与range函数类似， 我们可以使用arange函数来产生等差数组 12a = np.arange(0, 100, 10)a array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])花式索引需要指定索引位置 123index = [1, 2, -3]b = a[index]print(b) [10 20 70]还可以使用布尔数组来花式索引 12mask = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype = bool)mask array([False, True, False, True, False, True, False, True, False, True])mask必须是布尔数组， 长度必须和数组的长度相同 12b = a[mask]print(b) [10 30 50 70 90]二维花式索引对于二维花式索引， 我们需要给定行和列的值 12a = np.array([[1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])a array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])返回的是一条次对角线上的五个值 元组， zip, (), () 1a[(0, 1, 2, 3, 4, 5), (1, 2, 3, 4, 5, 6)] array([ 2, 13, 24, 35, 46, 57])返回的是最后三行的第1， 3， 5列 1a[-3:, 1:6:2] array([[32, 34, 36], [42, 44, 46], [52, 54, 56]])也可以使用mask进行索引 12mask = np.array([1, 0, 1, 0, 1, 0], dtype = bool)mask array([ True, False, True, False, True, False])1a[mask, 2] array([ 3, 23, 43])与切片不同， 花式索引返回的是原对象的一个复制而不是引用 “不完全”索引只给定行索引的时候， 返回整行 12y = a[:3]y array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28]])这时候也可以使用花式索引取出2， 3， 5行 长度必须相同 1234flag = np.array([0, 1, 1, 0, 1, 0], dtype = bool)flagy = a[flag]y array([[11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [41, 42, 43, 44, 45, 46, 47, 48]])where语句where(array) where函数会返回所有非零函数的索引 一维数组先看一维的例子 12a = np.array([12, 15, 18, 0, 1, 2, 8])a array([12, 15, 18, 0, 1, 2, 8])判断数组中的元素是不是大于10 1a&gt;10 array([ True, True, True, False, False, False, False])数组中所有大于10的元素的索引位置 1np.where(a&gt;10) (array([0, 1, 2], dtype=int32),)注意到where的返回值是一个元组， 返回的是索引位置， 索引[1, 1, 2]大于10的数 也可以直接用数组操作 1a[a&gt;10] array([12, 15, 18])1a[np.where(a&gt;10)] array([12, 15, 18])数组类型类型转换12a = np.array([1.5, -3], dtype = float)a array([ 1.5, -3. ])asarray函数类型转换， 第一个是需要转换的数组， 第二是需要转换的类型， dtype = float 12a = np.array([1, 2, 3])np.asarray(a, dtype = float) array([1., 2., 3.])astype 方法astype 方法返回一个新数组,返回一个新的数组， copy 12a = np.array([1, 2, 3])a.astype(float) array([1., 2., 3.])数组操作我们以豆瓣十部高分电影为例1234567891011# 电影名称mv_name = ['肖申克的救赎', '控方证人','美丽人生' ,'阿甘正传','霸王别姬','泰坦尼克号 ','辛德勒的名单','新世纪福音战士剧场版：Air/真心为你 新世紀エヴァンゲリオン劇場版 Ai','银魂完结篇：直到永远的万事屋 劇場版 銀魂 完結篇 万事屋よ'] 1234567891011# 评分人数mv_num = np.array([692795,42995,327855,580897,478523,157074,306904,24355,21513]) 1234567891011# 评分mv_score = np.array([9.6,9.5,9.5,9.4,9.4,9.4,9.4,9.4,9.4]) 1234567891011# 电影时长mv_length = np.array([142,116,116,142,171,194,195,87,110]) 数组排序sort函数从小到大排序 1np.sort(mv_num) array([ 21513, 24355, 42995, 157074, 306904, 327855, 478523, 580897, 692795])1mv_num array([692795, 42995, 327855, 580897, 478523, 157074, 306904, 24355, 21513])argsort函数argsort 返回从小到大的排序在数组中的索引位置 1np.argsort(mv_num) array([8, 7, 1, 5, 6, 2, 4, 3, 0], dtype=int32)求和1np.sum(mv_num) 26329111mv_num.sum() 2632911求最大值1np.max(mv_num) 6927951mv_num.max() 692795求最小值1mv_num.min() 21513均值1mv_num.mean() 292545.66666666671np.mean(mv_num) 292545.6666666667标准差1np.std(mv_num) 236971.528371846571mv_num.mean() 292545.6666666667相关系数矩阵1np.cov(mv_score, mv_length) array([[ 5.27777778e-03, -6.22222222e-01], [-6.22222222e-01, 1.46902778e+03]])多维数组的操作数组形状12a = np.arange(0, 6)a array([0, 1, 2, 3, 4, 5])12a.shape = 2, 3a array([[0, 1, 2], [3, 4, 5]])与之对应的方法是reshape， 但它不会修改原来数组的值， 而是返回一个新的数组 1234a = np.arange(6)b = a.reshape(2, 3)bprint(a) [0 1 2 3 4 5]转置1b.T array([[0, 3], [1, 4], [2, 5]])1b.transpose() array([[0, 3], [1, 4], [2, 5]])数组连接有时我们需要将不同的数组按照一定的顺序连接起来 concatenate((a0, a1, …., aN), axis = 0) axis方向 0默认， 默认按照纵向来进行拼接 1可更改， 按照横向进行拼接 注意： 这些数组要用（）， 包含到一个元组中去 除了给定的轴外， 这些数组其他轴的长度必须是一样的 123456a = np.arange(6)b = np.arange(6)a.shape = 2, 3b.shape = 2, 3print(a.shape)print(b.shape) (2, 3) (2, 3)默认沿着第一维进行连接 12z = np.concatenate((a, b))z array([[0, 1, 2], [3, 4, 5], [0, 1, 2], [3, 4, 5]])沿着第二维进行连接 12z = np.concatenate((a, b), axis = 1)z array([[0, 1, 2, 0, 1, 2], [3, 4, 5, 3, 4, 5]])注意到这里x和y的形状是一样的， 还可以将他们连接成三维的数组， 但是concatenate不能提供这样的功能， 不过可以这样： vstack hstack dstack 1np.vstack((a, b)) array([[0, 1, 2], [3, 4, 5], [0, 1, 2], [3, 4, 5]])1np.hstack((a, b)) array([[0, 1, 2, 0, 1, 2], [3, 4, 5, 3, 4, 5]])12z = np.dstack((a, b))z array([[[0, 0], [1, 1], [2, 2]], [[3, 3], [4, 4], [5, 5]]])1z[0] array([[0, 0], [1, 1], [2, 2]])1z[0,0] array([0, 0])1z[0, 0, 0] 0求绝对值1a = np.array([-1, 2, 3, -2]) 1np.abs(a) array([1, 2, 3, 2])求指数1np.exp(a) array([ 0.36787944, 7.3890561 , 20.08553692, 0.13533528])求中值1np.median(a) 0.5求累计和1np.cumsum(a) 1array([-1, 1, 4, 2], dtype=int32)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析基础语法]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据类型常用数据类型 属性 类型 例子 电影名 字符串 肖申克的救赎 观影人数 整数 692795 评分 浮点数 9.6 中国大陆 布尔值 False 投资额 空值 None 字符串字符串的定义是使用引号来定义，单引号于双引号是等价的 三引号用来输入包含多行文字的字符串 1234s = '''hellomyworld'''print(s) 字符串的加法 12s = 'hello' + 'world's 字符串的索引 把字符串中的单个字母拿出来， 下标从零开始 1s[0] 字符串的分割 默认用空格进行分割 1234s = 'hello world's.split( )a = 'hello,world's.split(',') 查看字符串的长度 1len(s) 整数浮点数布尔值1234a = Trueaa = 1 &gt; 2a = False 空值12345a = ''alen(a)a = Nonea 运算符描述 + 两数相加 - 两数相减 * 两数相乘 / 两数相除 % 取模 // 相除取整 ** 去幂次方 比较运算 == 等于 != 不等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 赋值运算 = a = 3 += a = a + 3 -= a = a - 3 *= a = a * 3 /= a = a / 3 %= a = a % 3 **= a = a ** 3 //= a = a // 3 逻辑运算 and &amp; or | not not 12345a = 5 &gt; 4b = Truenot aa|ba&amp;b 数据结构列表ListPython用[]来生成列表， 也可以用list关键字 列表操作 一定要是英文状态的逗号和单引号 列表里面允许各个元素的数据类型不一样 1234567a = [1, 2, 3, 4, 5]aactors = ['Tyrion', 'Smith', 'Jogger']actorsb = [1, 2.3, 'Tyrion']blist('abcde') 列表的操作12345678910111213141516171819202122232425#列表的相加a+b#列表的取值a[0] #索引从0开始#增加列表#在末尾增加a.append()#可以增加各种不同的数据类型#在特定位置增加a.insert(1, 10)#在列表的坐标的位置为1的地方插入10这个元素#删除列表的元素#默认删除最后的一个元素a.pop()a.pop(1)#删除列表的坐标的位置为1的元素#数据切片a[0:3]#左闭右开#取出列表a的第0， 1， 2个元素a[:3]#默认从最开头取出元素a[0:]#默认取到列表的最后一个元素#允许有负数， 相当于一个环a[0:-1]#除了最后一个元素没有被取出来，其他全部都被取出来#间隔取值a[2:9:3]#从索引号2开始取值， 到索引号9结束， 9不被包括， 间隔为3 元组tuple另一种有序列表叫做元组：tuple，用()来表示。 tuple和list非常类似，但是tuple一旦被初始化就不能被修改 12345678910a = (1, 2, 3, 4, 5, 6)经常当作常数来使用#其他的操作和list相同，除了插入修改append不能使用insert不能使用pop不能使用可以使用索引a[0]可以使用切片a[0:] 字典dictPython用{ key: value }来生成Dictionary 1234567891011121314151617mv = &#123;'name':'肖申克的救赎', 'actor':'Tyrion', 'score':'9.6', 'country':'American'&#125;#数据类型可以是不同的数据类型mvmv['name']#查看字典中所有的keysmv.keys()#查看字典中所有的valuemv.value()#查看字典中所有的itemsmv.items()#修改字典中的元素#修改mv['name'] = '泰坦尼克号'#插入mv['directors'] = '德拉邦特'#删除mv.pop('directors') 集合setPython用{}来生成集合， 集合中不含有相同的元素 1234567891011s1 = &#123;2, 3, 4, 2&#125;s1len(s1)#增加元素s1.add()#集合的交并集的概念s2 = &#123;1， 2， 4， 7， 9&#125;s1&amp;s2 #做交集s1|s2 #做并集s1 - s2 #属于s1 但是 不属于 s2 的元素s2 - s1 #属于s2 但是 不属于 s1 的元素 可变对象和不可变对象可变对象可以对其进行插入，删除等操作， 不可变对象不可以对其进行有改变的操作 python中列表（list） 字典（dictionary）集合（set）都是可变的 元组（tuple）整型，字符串都是不可变的 类型转换12345int(3.14)float(3)s = 'abcd'type(s)list(s) 判断和循环python里面是区分大小写的 123456789101112131415161718192021222324252 == 23 == 'a'if 2 &gt; 1: print('hello')else: print('world')x = 0if x &gt; 0: print('True')elif x == 0: print('Zero')else: print('False')#循环#for循环for i in [1,2,3,4,5,6]: print(i)#while循环i = 1while i &lt; 10: print(i) i+=1for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: if i % 2 == 1: print(i) 列表生成式列表生成式即List Comprehension， 是python内置的非常简单却强大的可以用来创建list的生成式 123456list(range(1, 11))#左闭右开[x**2 for x in range(1, 10)][i for i in range(1, 100) if i%10==0][str(x) for x in range(1, 10)][int(x) for x in list(&apos;123456789&apos;)] python函数内置函数123456789#取绝对值函数abs(-1)a = [2, 3, -1, 4]#找到最大的值max(a)#找到最小的值min(a)#求和sum(a) 自定义函数函数function， 通常接受输入参数， 并有返回值 它负责完成某项特定的任务， 而且相较于其他代码，具备相对的独立性 函数通常有以下的几个特征： 使用def关键字来定义一个函数 def后面是函数的名称， 括号是函数的参数， 不同的参数用， 隔开， def func():的形式是必须要有的，参数可以为空； 使用缩进来划分函数的内容 return 返回特定的值， 如果省略， 返回None 使用函数时， 只需要将参数换成特定的值传给函数 python中并没有限定参数的类型，因此可以使用不同的参数类型： 在这个例子中， 如果传入的两个参数不可以相加， 那么python会将报错： 如果传入的参数数目与实际不符合， 也会报错： 可以在函数定义的时候给参数设定默认值 1234567def add(a, b): return a+bdef func(x, a = 1, b = 0, c = 0): return a*x**2+b*x+cdef f(x): return x**2, x**3#f(2), return (4, 8)元组常数，不可以更改 第一作业总结 列表生成式 1[f(i) for i in range(begin , end) if i != error] 判断一个数字或者一个字符串是否在一个列表当中 1want_find in list1 数据切片 123456#倒序输出i[::-1]#奇数输出i[::2]#偶数输出i[1::2]]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
