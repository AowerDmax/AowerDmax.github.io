<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[word版本管理工具]]></title>
    <url>%2F2019%2F07%2F21%2Fword%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[最近在用word写论文， 虽然我认为word并不是一个写论文的好工具。 但毕竟写论文是一个团队协作共同完成的工作，也要配合团队其他成员所使用的工具 所以最终我们选择了word 但是在攥写论文的过程中，我发现了一系列的问题 因为论文需要不断的更改，加上命名不规范， 最终会导致一系列的问题， 如下图所示， 随着时间和文件数目的增多， 我们最终会忘记每个文件都更改了什么， 无法快速找到自己想要的版本 无法快速的对任意两个版本之间的不同进行比较 在多人协作的时候，往往因为论文的整合而出现一些问题 团队使用q q作为通讯联络工具， 在进行多人讨论时，随着聊天记录的边长， 往往会遗漏一些要点 所以针对以上问题， 我寻找了一款名叫Simul的网页版的word版本控制工具 开始时想要使用Git工具， Github是流行的文本版本控制工具，在工业界和程序员中取得了巨大成功，但Github也具有其自身的局限，只支持纯文本，不支持像Word一样的富文本。这让Github在需要富文本编辑的场景中严重水土不服。Simul，就是解决这一痛点，把Github的版本控制功能整合到Word的富文本文档中。 Simul是一个文档协作工具，把Github的优秀版本控制特性带到Word中来。该工具为长期与他人协作编辑文档的人群量身打造，比如学者、律师、记者、作家。以学术工作者为例，无论你是学生还是导师，在书写手稿的时候，是不是有无数个v1,v1_1,v2_1,…，是不是需要无数次的从不同版本中进行人工的比较、编辑和整合。这样的痛苦可能存在于每个需要协作编辑的文字工作者中，Simul为你解决以上痛点。 那么话不多说我们就开始今天的教程吧h h 访问 simul 官网 点击 Get started for free 下方的 register 根据要求进行注册， 这里推荐使用Google账号进行注册， 如果实在没有也没有关系， 第一个是组织名称，第二个是你的名字， 这些都不重要， 最重要的是你的邮箱和密码， 国内可能速度会慢一些， 但还是可以使用的， 然后再最下面的I configure 那里打上对号 登陆后的界面如下， 点击add a new document 点击之后会弹出一个窗口 第一个upload指的是你从本地上传word文档 第二个是创建一个空白的文档 第三个是从你的云盘文件中导入， 支持SharePoint， OneDrive， Dropbox， Google drive， box 可以说是非常良心了 ， 我平常对一些重要文件进行Dropbox备份， 可以说是非常贴近我的用户习惯了h h， 因为我这里使用的是免费版的， 最多只能上传十篇word（只要你邮箱多， 那你就是无数个）滑稽 点击中间的browse， 找到本地你想要上传的word文档， 然后点击右下角的打开 至于最下面的， 是询问你是否要创建一个文件夹， 我觉得十篇word没必要， 所以直接点击upload 然后点击close， 你就可以看到你的文档已经上传了， 左键单击你上传的项目， 会得到如下的界面 部分说明我已经在图上进行了说明 先点击右上角的三个点， 出现菜单栏 我们经常用到的按钮是 Download a copy 还有 import a new version publish this version 指的是将当前文档设置为主分支， 可以更好的进行版本控制 name this version 对当前版本进行重命名 push to copy 协同工作的时候很有用 Download a copy 将当前版本下载下来 import a new version上传一个新的版本 下面我对我上传的test文档进行一定的修改， 注意是在本地更改， 网页上不可以更改 ，网页上只能预览， 除非你有office365. 将第二个是创建一个空白的文档第二个是创建一个空白的文档这句话更改为快速的棕色狐狸跳过懒狗 在最下面增加word这句话， 然后import a new version 至于upload in separate brank这个是指创建一个新的分支， 当你有多种想法的时候， 可以使用这个来朝着不同方向进行， 这里我们直接点击IMPORT 通过给自己创建任务 防止自己遗忘重要事情，尤其是当q q聊天记录过多时 可以给自己设定期限， 给自己完成任务的紧迫感 可以提醒搭档， 更好的分工配合 同时simul还支持多人协作的模式 在email 那里填写你同伴的email地址 下面是给你的同伴说明权限， 是贡献者， 还是主人， 还是只能观看 最后点击invite就完成了 这些只是simul的基本操作 如果你想要继续深入的学习， 这里推荐simul的介绍和说明文档]]></content>
      <tags>
        <tag>版本管理</tag>
        <tag>word</tag>
        <tag>多人协作</tag>
        <tag>版本回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F07%2F21%2FGit%2F</url>
    <content type="text"><![CDATA[Git是一个版本管理的工具， 他可以在]]></content>
      <tags>
        <tag>git</tag>
        <tag>版本管理</tag>
        <tag>实用小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言基本语法与绘图指北]]></title>
    <url>%2F2019%2F07%2F21%2FR%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%B8%8E%E7%BB%98%E5%9B%BE%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ss/ssr搭建指北]]></title>
    <url>%2F2019%2F07%2F21%2Fss-ssr%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"></content>
      <tags>
        <tag>ssr</tag>
        <tag>科学上网</tag>
        <tag>ss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类图的分析与研究]]></title>
    <url>%2F2019%2F07%2F21%2F%E8%81%9A%E7%B1%BB%E5%9B%BE%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析Pandas]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90Pandas%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析numpy]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90numpy%2F</url>
    <content type="text"><![CDATA[Python数据分析之numpyNumpy是Python的一种开源的数值计算扩展。这种工具可用来储存和处理大型矩阵比Python自身的嵌套列表（nested list structure）结构要高效的多。numpy提供了许多高级的数值编程工具。Numpy的一个重要特性是它的数组计算，是做数据分析必不可少的一个包 导入python库使用关键字import， 后面可以自定义库的简称， 但是一般都将Numpy命名为np， pandas命名为pd 使用前一定要先导入Numpy包， 导入的方式有以下几种 import numpy 导入numpy包， 在使用numpy里面的函数时， 必须是numpy. 的形式 import numpy as np 导入numpy包， 并将其重命名为np， 在使用numpy里的函数时， 必须是 np. 的形式 from numpy import * 不用加任何前缀， 速度较慢， 且容易发生冲突， 不建议使用 1import numpy as np 1.Numpy的数组对象及其索引数组上的数学操作假如我们想将列表中的每个元素增加1，但列表不支持这样的操作： 12a = [1, 2, 3, 4, 5][x+1 for x in a] [2, 3, 4, 5, 6]12b = [2, 3, 4, 5, 6]a+b [1, 2, 3, 4, 5, 2, 3, 4, 5, 6]zip是一个打包命令可以让a, b 列表组成一个一个的数对 1[x+y for (x, y) in zip(a, b)] [3, 5, 7, 9, 11]与另一个数组相加，得到对应元素相加的结果： 这样的操作比较麻烦，而且在数据量特别大的时候会非常耗时间如果我们使用numpy， 就会变得特别简单初始化一个numpy数组12a = np.array([1, 2, 3, 4])a array([1, 2, 3, 4])1a+1 array([2, 3, 4, 5])1a * 2 array([2, 4, 6, 8])产生数组从列表产生数组 123list1 = [1, 2, 3, 4]my_list = np.array(list1)my_list array([1, 2, 3, 4])从列表传入数组 12my_list = np.array([0, 1, 2, 3])my_list array([0, 1, 2, 3])生成全0数组 1np.zeros(5) array([0., 0., 0., 0., 0.])生成全1数组 默认生成的数组为浮点型， 若要进行类型的转换可以使用dtype 1np.ones(5,dtype = 'int') array([1, 1, 1, 1, 1])可以使用fill方法将数组设为指定值 123a = np.zeros(6, dtype = 'int')a.fill(5)a array([5, 5, 5, 5, 5, 5])与列表不同， 数组中要求所有元素的type是一样的， 如果传入参数的类型与数组类型不一样， 需按照已有的类型进行转换 12a = a.astype('float')a array([5., 5., 5., 5., 5., 5.])还可以使用一些特定的方法生成特殊数组 生成整数序列 123# 生成整数序列， 左闭右开， 不包含右边a = np.arange(1, 10)a array([1, 2, 3, 4, 5, 6, 7, 8, 9])123# 第三个参数指定相邻元素的差值a = np.arange(1, 10, 2)a array([1, 3, 5, 7, 9])生成等差数列 123# linsapce 生成等差数列， 包含1到10， 平均等分为19份a = np.linspace(1, 10, 19)a array([ 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5, 7. , 7.5, 8. , 8.5, 9. , 9.5, 10. ])生成随机数 123# 生成的随机数分布在0~1之间， 左闭右开# 生成10个随机数np.random.rand(10) array([0.47858337, 0.27552828, 0.23564354, 0.32176268, 0.0649055 , 0.06550039, 0.10144269, 0.09723159, 0.39374272, 0.2053621 ])服从标准正态分布的随机数 1np.random.randn(10) array([-1.71106368, 0.01290357, 0.11539743, 0.0945762 , 0.27211728, -1.72631161, -0.07228001, 1.78744359, -0.04889052, 0.47681058])1np.random.randint(1, 10, 10) array([4, 7, 2, 1, 7, 7, 3, 9, 7, 7])数组属性查看类型 1a array([ 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5, 7. , 7.5, 8. , 8.5, 9. , 9.5, 10. ])1type(a) numpy.ndarray查看数组中的数据类型 1a.dtype dtype(&apos;float64&apos;)查看形状， 会返回一个元组， 每一个元素代表这一堆的元素数目 1a.shape (19,)或者使用： 1np.shape(a) (19,)1np.size(a) 19查看数组里面元素的数目 1a.size 19查看数组的维度 1a.ndim 1索引和切片和列表相似， 数组也支持索引和切片操作 索引第一个元素 12a = np.array([1, 2, 3])a[0] 1修改第一个元素的值 12a[0] = 10a array([10, 2, 3])切片， 支持负索引： 12# 注意左闭右开a[::-1] array([ 3, 2, 10])假设我们记录一部电影的累计票房 12ob = np.array([1000, 2100, 3300, 4600, 6000])ob array([1000, 2100, 3300, 4600, 6000])可以这样计算每天的票房 12front_ob = ob[:-1]front_ob array([1000, 2100, 3300, 4600])12back_ob = ob[1:]back_ob array([2100, 3300, 4600, 6000])12end_ob = back_ob - front_obend_ob array([1100, 1200, 1300, 1400])多维数组及其属性array还可以用来生成多为数组 12a = np.array([[0, 1, 2, 3], [10, 11, 12, 13]])a array([[ 0, 1, 2, 3], [10, 11, 12, 13]])事实上我们传入的是一个以列表为元素的列表， 最终得到一个二维数组 查看形状 1np.shape(a) (2, 4)查看总的元素个数 1a.size 8查看维数 1a.ndim 2各维数组索引对于二维数组， 可以传入两个数字来索引 1a array([[ 0, 1, 2, 3], [10, 11, 12, 13]])可以通过两个中括号的形式或者一个中括号里面有逗号的形式来进行索引 12a[1][2]a[1, 3] 13可以使用单个索引来索引一整行的内容 也可以使用索引来给一整行进行赋值 1a[0] array([0, 1, 2, 3])可以使用索引来索引一整列的内容 1a[:, 1] array([0, 1, 2, 3])多维数组的切片多维数组， 也支持切片操作 12a = np.array([[1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])a array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])想得到第一行的第四和第五两个元素 1a[0, 4:6] array([5, 6])想得到最后两行的最后两列 1a[-2:,-2:] array([[47, 48], [57, 58]])得到第三列 1a[:, 2] array([ 3, 13, 23, 33, 43, 53])每一维都支持切片的规则，包括负索引， 省略 [lower:upper:step] 取出3， 5行的奇数列 1a[3::2, ::2] array([[31, 33, 35, 37], [51, 53, 55, 57]])切片是引用 切片在内存中使用的是引用机制 列表list和数组使用的机制是不一样的 list使用copy 数组使用引用 12345a = np.array([1, 2, 3, 4, 5])b = a[1:3]print(b)b[0] = 10print(a) [2 3] [ 1 10 3 4 5]123456a = [1, 2, 3, 4, 5]b = a[2:3]print(b)b[0] = 10print(b)print(a) [3] [10] [1, 2, 3, 4, 5]引用机制意味着， Python并没有为b分配新的空间来储存它的值， 而是让b指向了a所分配的内存空间， 因此， 改变b 会改变a 的值 这样做的好处在于， 对于很大的数组， 不用大量复制多余的值， 节省了空间 缺点在于， 可能出现改变一个值改变另一个值的情况 一个解决方案是使用copy()方法产生一个复制， 这个复制会申请新的内存 12345a = np.array([1, 2, 3, 4, 5])b = a[2:4].copy()print(b)b[0] = 10print(a) [3 4] [1 2 3 4 5]花式索引切片只能支持连续或者等间隔的切片操作， 要想实现任意位置的操作， 需要使用花式索引 fancy slicing 一维花式索引与range函数类似， 我们可以使用arange函数来产生等差数组 12a = np.arange(0, 100, 10)a array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])花式索引需要指定索引位置 123index = [1, 2, -3]b = a[index]print(b) [10 20 70]还可以使用布尔数组来花式索引 12mask = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype = bool)mask array([False, True, False, True, False, True, False, True, False, True])mask必须是布尔数组， 长度必须和数组的长度相同 12b = a[mask]print(b) [10 30 50 70 90]二维花式索引对于二维花式索引， 我们需要给定行和列的值 12a = np.array([[1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])a array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [31, 32, 33, 34, 35, 36, 37, 38], [41, 42, 43, 44, 45, 46, 47, 48], [51, 52, 53, 54, 55, 56, 57, 58]])返回的是一条次对角线上的五个值 元组， zip, (), () 1a[(0, 1, 2, 3, 4, 5), (1, 2, 3, 4, 5, 6)] array([ 2, 13, 24, 35, 46, 57])返回的是最后三行的第1， 3， 5列 1a[-3:, 1:6:2] array([[32, 34, 36], [42, 44, 46], [52, 54, 56]])也可以使用mask进行索引 12mask = np.array([1, 0, 1, 0, 1, 0], dtype = bool)mask array([ True, False, True, False, True, False])1a[mask, 2] array([ 3, 23, 43])与切片不同， 花式索引返回的是原对象的一个复制而不是引用 “不完全”索引只给定行索引的时候， 返回整行 12y = a[:3]y array([[ 1, 2, 3, 4, 5, 6, 7, 8], [11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28]])这时候也可以使用花式索引取出2， 3， 5行 长度必须相同 1234flag = np.array([0, 1, 1, 0, 1, 0], dtype = bool)flagy = a[flag]y array([[11, 12, 13, 14, 15, 16, 17, 18], [21, 22, 23, 24, 25, 26, 27, 28], [41, 42, 43, 44, 45, 46, 47, 48]])where语句where(array) where函数会返回所有非零函数的索引 一维数组先看一维的例子 12a = np.array([12, 15, 18, 0, 1, 2, 8])a array([12, 15, 18, 0, 1, 2, 8])判断数组中的元素是不是大于10 1a&gt;10 array([ True, True, True, False, False, False, False])数组中所有大于10的元素的索引位置 1np.where(a&gt;10) (array([0, 1, 2], dtype=int32),)注意到where的返回值是一个元组， 返回的是索引位置， 索引[1, 1, 2]大于10的数 也可以直接用数组操作 1a[a&gt;10] array([12, 15, 18])1a[np.where(a&gt;10)] array([12, 15, 18])数组类型类型转换12a = np.array([1.5, -3], dtype = float)a array([ 1.5, -3. ])asarray函数类型转换， 第一个是需要转换的数组， 第二是需要转换的类型， dtype = float 12a = np.array([1, 2, 3])np.asarray(a, dtype = float) array([1., 2., 3.])astype 方法astype 方法返回一个新数组,返回一个新的数组， copy 12a = np.array([1, 2, 3])a.astype(float) array([1., 2., 3.])数组操作我们以豆瓣十部高分电影为例1234567891011# 电影名称mv_name = ['肖申克的救赎', '控方证人','美丽人生' ,'阿甘正传','霸王别姬','泰坦尼克号 ','辛德勒的名单','新世纪福音战士剧场版：Air/真心为你 新世紀エヴァンゲリオン劇場版 Ai','银魂完结篇：直到永远的万事屋 劇場版 銀魂 完結篇 万事屋よ'] 1234567891011# 评分人数mv_num = np.array([692795,42995,327855,580897,478523,157074,306904,24355,21513]) 1234567891011# 评分mv_score = np.array([9.6,9.5,9.5,9.4,9.4,9.4,9.4,9.4,9.4]) 1234567891011# 电影时长mv_length = np.array([142,116,116,142,171,194,195,87,110]) 数组排序sort函数从小到大排序 1np.sort(mv_num) array([ 21513, 24355, 42995, 157074, 306904, 327855, 478523, 580897, 692795])1mv_num array([692795, 42995, 327855, 580897, 478523, 157074, 306904, 24355, 21513])argsort函数argsort 返回从小到大的排序在数组中的索引位置 1np.argsort(mv_num) array([8, 7, 1, 5, 6, 2, 4, 3, 0], dtype=int32)求和1np.sum(mv_num) 26329111mv_num.sum() 2632911求最大值1np.max(mv_num) 6927951mv_num.max() 692795求最小值1mv_num.min() 21513均值1mv_num.mean() 292545.66666666671np.mean(mv_num) 292545.6666666667标准差1np.std(mv_num) 236971.528371846571mv_num.mean() 292545.6666666667相关系数矩阵1np.cov(mv_score, mv_length) array([[ 5.27777778e-03, -6.22222222e-01], [-6.22222222e-01, 1.46902778e+03]])多维数组的操作数组形状12a = np.arange(0, 6)a array([0, 1, 2, 3, 4, 5])12a.shape = 2, 3a array([[0, 1, 2], [3, 4, 5]])与之对应的方法是reshape， 但它不会修改原来数组的值， 而是返回一个新的数组 1234a = np.arange(6)b = a.reshape(2, 3)bprint(a) [0 1 2 3 4 5]转置1b.T array([[0, 3], [1, 4], [2, 5]])1b.transpose() array([[0, 3], [1, 4], [2, 5]])数组连接有时我们需要将不同的数组按照一定的顺序连接起来 concatenate((a0, a1, …., aN), axis = 0) axis方向 0默认， 默认按照纵向来进行拼接 1可更改， 按照横向进行拼接 注意： 这些数组要用（）， 包含到一个元组中去 除了给定的轴外， 这些数组其他轴的长度必须是一样的 123456a = np.arange(6)b = np.arange(6)a.shape = 2, 3b.shape = 2, 3print(a.shape)print(b.shape) (2, 3) (2, 3)默认沿着第一维进行连接 12z = np.concatenate((a, b))z array([[0, 1, 2], [3, 4, 5], [0, 1, 2], [3, 4, 5]])沿着第二维进行连接 12z = np.concatenate((a, b), axis = 1)z array([[0, 1, 2, 0, 1, 2], [3, 4, 5, 3, 4, 5]])注意到这里x和y的形状是一样的， 还可以将他们连接成三维的数组， 但是concatenate不能提供这样的功能， 不过可以这样： vstack hstack dstack 1np.vstack((a, b)) array([[0, 1, 2], [3, 4, 5], [0, 1, 2], [3, 4, 5]])1np.hstack((a, b)) array([[0, 1, 2, 0, 1, 2], [3, 4, 5, 3, 4, 5]])12z = np.dstack((a, b))z array([[[0, 0], [1, 1], [2, 2]], [[3, 3], [4, 4], [5, 5]]])1z[0] array([[0, 0], [1, 1], [2, 2]])1z[0,0] array([0, 0])1z[0, 0, 0] 0求绝对值1a = np.array([-1, 2, 3, -2]) 1np.abs(a) array([1, 2, 3, 2])求指数1np.exp(a) array([ 0.36787944, 7.3890561 , 20.08553692, 0.13533528])求中值1np.median(a) 0.5求累计和1np.cumsum(a) 1array([-1, 1, 4, 2], dtype=int32)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数据分析</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python数据分析基础语法]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据类型常用数据类型 属性 类型 例子 电影名 字符串 肖申克的救赎 观影人数 整数 692795 评分 浮点数 9.6 中国大陆 布尔值 False 投资额 空值 None 字符串字符串的定义是使用引号来定义，单引号于双引号是等价的 三引号用来输入包含多行文字的字符串 1234s = '''hellomyworld'''print(s) 字符串的加法 12s = 'hello' + 'world's 字符串的索引 把字符串中的单个字母拿出来， 下标从零开始 1s[0] 字符串的分割 默认用空格进行分割 1234s = 'hello world's.split( )a = 'hello,world's.split(',') 查看字符串的长度 1len(s) 整数浮点数布尔值1234a = Trueaa = 1 &gt; 2a = False 空值12345a = ''alen(a)a = Nonea 运算符描述 + 两数相加 - 两数相减 * 两数相乘 / 两数相除 % 取模 // 相除取整 ** 去幂次方 比较运算 == 等于 != 不等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 赋值运算 = a = 3 += a = a + 3 -= a = a - 3 *= a = a * 3 /= a = a / 3 %= a = a % 3 **= a = a ** 3 //= a = a // 3 逻辑运算 and &amp; or | not not 12345a = 5 &gt; 4b = Truenot aa|ba&amp;b 数据结构列表ListPython用[]来生成列表， 也可以用list关键字 列表操作 一定要是英文状态的逗号和单引号 列表里面允许各个元素的数据类型不一样 1234567a = [1, 2, 3, 4, 5]aactors = ['Tyrion', 'Smith', 'Jogger']actorsb = [1, 2.3, 'Tyrion']blist('abcde') 列表的操作12345678910111213141516171819202122232425#列表的相加a+b#列表的取值a[0] #索引从0开始#增加列表#在末尾增加a.append()#可以增加各种不同的数据类型#在特定位置增加a.insert(1, 10)#在列表的坐标的位置为1的地方插入10这个元素#删除列表的元素#默认删除最后的一个元素a.pop()a.pop(1)#删除列表的坐标的位置为1的元素#数据切片a[0:3]#左闭右开#取出列表a的第0， 1， 2个元素a[:3]#默认从最开头取出元素a[0:]#默认取到列表的最后一个元素#允许有负数， 相当于一个环a[0:-1]#除了最后一个元素没有被取出来，其他全部都被取出来#间隔取值a[2:9:3]#从索引号2开始取值， 到索引号9结束， 9不被包括， 间隔为3 元组tuple另一种有序列表叫做元组：tuple，用()来表示。 tuple和list非常类似，但是tuple一旦被初始化就不能被修改 12345678910a = (1, 2, 3, 4, 5, 6)经常当作常数来使用#其他的操作和list相同，除了插入修改append不能使用insert不能使用pop不能使用可以使用索引a[0]可以使用切片a[0:] 字典dictPython用{ key: value }来生成Dictionary 1234567891011121314151617mv = &#123;'name':'肖申克的救赎', 'actor':'Tyrion', 'score':'9.6', 'country':'American'&#125;#数据类型可以是不同的数据类型mvmv['name']#查看字典中所有的keysmv.keys()#查看字典中所有的valuemv.value()#查看字典中所有的itemsmv.items()#修改字典中的元素#修改mv['name'] = '泰坦尼克号'#插入mv['directors'] = '德拉邦特'#删除mv.pop('directors') 集合setPython用{}来生成集合， 集合中不含有相同的元素 1234567891011s1 = &#123;2, 3, 4, 2&#125;s1len(s1)#增加元素s1.add()#集合的交并集的概念s2 = &#123;1， 2， 4， 7， 9&#125;s1&amp;s2 #做交集s1|s2 #做并集s1 - s2 #属于s1 但是 不属于 s2 的元素s2 - s1 #属于s2 但是 不属于 s1 的元素 可变对象和不可变对象可变对象可以对其进行插入，删除等操作， 不可变对象不可以对其进行有改变的操作 python中列表（list） 字典（dictionary）集合（set）都是可变的 元组（tuple）整型，字符串都是不可变的 类型转换12345int(3.14)float(3)s = 'abcd'type(s)list(s) 判断和循环python里面是区分大小写的 123456789101112131415161718192021222324252 == 23 == 'a'if 2 &gt; 1: print('hello')else: print('world')x = 0if x &gt; 0: print('True')elif x == 0: print('Zero')else: print('False')#循环#for循环for i in [1,2,3,4,5,6]: print(i)#while循环i = 1while i &lt; 10: print(i) i+=1for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: if i % 2 == 1: print(i) 列表生成式列表生成式即List Comprehension， 是python内置的非常简单却强大的可以用来创建list的生成式 123456list(range(1, 11))#左闭右开[x**2 for x in range(1, 10)][i for i in range(1, 100) if i%10==0][str(x) for x in range(1, 10)][int(x) for x in list(&apos;123456789&apos;)] python函数内置函数123456789#取绝对值函数abs(-1)a = [2, 3, -1, 4]#找到最大的值max(a)#找到最小的值min(a)#求和sum(a) 自定义函数函数function， 通常接受输入参数， 并有返回值 它负责完成某项特定的任务， 而且相较于其他代码，具备相对的独立性 函数通常有以下的几个特征： 使用def关键字来定义一个函数 def后面是函数的名称， 括号是函数的参数， 不同的参数用， 隔开， def func():的形式是必须要有的，参数可以为空； 使用缩进来划分函数的内容 return 返回特定的值， 如果省略， 返回None 使用函数时， 只需要将参数换成特定的值传给函数 python中并没有限定参数的类型，因此可以使用不同的参数类型： 在这个例子中， 如果传入的两个参数不可以相加， 那么python会将报错： 如果传入的参数数目与实际不符合， 也会报错： 可以在函数定义的时候给参数设定默认值 1234567def add(a, b): return a+bdef func(x, a = 1, b = 0, c = 0): return a*x**2+b*x+cdef f(x): return x**2, x**3#f(2), return (4, 8)元组常数，不可以更改 第一作业总结 列表生成式 1[f(i) for i in range(begin , end) if i != error] 判断一个数字或者一个字符串是否在一个列表当中 1want_find in list1 数据切片 123456#倒序输出i[::-1]#奇数输出i[::2]#偶数输出i[1::2]]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
